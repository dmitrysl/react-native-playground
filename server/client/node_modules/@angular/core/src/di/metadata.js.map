{"version":3,"file":"metadata.js","sourceRoot":"","sources":["../../../../../modules/@angular/core/src/di/metadata.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;OAGI,EAAC,kBAAkB,EAAC,MAAM,oBAAoB;AA6DrD;;;;;GAKG;AACH,OAAO,IAAM,MAAM,GAAoB,kBAAkB,CAAC,QAAQ,EAAE,CAAC,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC;AA0C5F;;;;;GAKG;AACH,OAAO,IAAM,QAAQ,GAAsB,kBAAkB,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC;AAmD9E;;;;;GAKG;AACH,OAAO,IAAM,UAAU,GAAwB,kBAAkB,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;AA+CpF;;;;;GAKG;AACH,OAAO,IAAM,IAAI,GAAkB,kBAAkB,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;AA8ClE;;;;;GAKG;AACH,OAAO,IAAM,QAAQ,GAAsB,kBAAkB,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC;AAwE9E;;;;;GAKG;AACH,OAAO,IAAM,IAAI,GAAkB,kBAAkB,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {stringify} from '../facade/lang';\nimport {makeParamDecorator} from '../util/decorators';\n\n/**\n * Type of the Inject decorator / constructor function.\n *\n * @stable\n */\nexport interface InjectDecorator {\n  /**\n   * A parameter metadata that specifies a dependency.\n   *\n   * ### Example ([live demo](http://plnkr.co/edit/6uHYJK?p=preview))\n   *\n   * ```typescript\n   * class Engine {}\n   *\n   * @Injectable()\n   * class Car {\n   *   engine;\n   *   constructor(@Inject(\"MyEngine\") engine:Engine) {\n   *     this.engine = engine;\n   *   }\n   * }\n   *\n   * var injector = Injector.resolveAndCreate([\n   *  {provide: \"MyEngine\", useClass: Engine},\n   *  Car\n   * ]);\n   *\n   * expect(injector.get(Car).engine instanceof Engine).toBe(true);\n   * ```\n   *\n   * When `@Inject()` is not present, {@link Injector} will use the type annotation of the\n   * parameter.\n   *\n   * ### Example\n   *\n   * ```typescript\n   * class Engine {}\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine: Engine) {} //same as constructor(@Inject(Engine) engine:Engine)\n   * }\n   *\n   * var injector = Injector.resolveAndCreate([Engine, Car]);\n   * expect(injector.get(Car).engine instanceof Engine).toBe(true);\n   * ```\n   * @stable\n   */\n  (token: any): any;\n  new (token: any): Inject;\n}\n\n/**\n * Type of the Inject metadata.\n *\n * @stable\n */\nexport interface Inject { token: any; }\n\n/**\n * Inject decorator and metadata.\n *\n * @stable\n * @Annotation\n */\nexport const Inject: InjectDecorator = makeParamDecorator('Inject', [['token', undefined]]);\n\n\n/**\n * Type of the Optional decorator / constructor function.\n *\n * @stable\n */\nexport interface OptionalDecorator {\n  /**\n   * A parameter metadata that marks a dependency as optional. {@link Injector} provides `null` if\n   * the dependency is not found.\n   *\n   * ### Example ([live demo](http://plnkr.co/edit/AsryOm?p=preview))\n   *\n   * ```typescript\n   * class Engine {}\n   *\n   * @Injectable()\n   * class Car {\n   *   engine;\n   *   constructor(@Optional() engine:Engine) {\n   *     this.engine = engine;\n   *   }\n   * }\n   *\n   * var injector = Injector.resolveAndCreate([Car]);\n   * expect(injector.get(Car).engine).toBeNull();\n   * ```\n   * @stable\n   */\n  (): any;\n  new (): Optional;\n}\n\n/**\n * Type of the Optional metadata.\n *\n * @stable\n */\nexport interface Optional {}\n\n/**\n * Optional decorator and metadata.\n *\n * @stable\n * @Annotation\n */\nexport const Optional: OptionalDecorator = makeParamDecorator('Optional', []);\n\n/**\n * Type of the Injectable decorator / constructor function.\n *\n * @stable\n */\nexport interface InjectableDecorator {\n  /**\n   * A marker metadata that marks a class as available to {@link Injector} for creation.\n   *\n   * ### Example ([live demo](http://plnkr.co/edit/Wk4DMQ?p=preview))\n   *\n   * ```typescript\n   * @Injectable()\n   * class UsefulService {}\n   *\n   * @Injectable()\n   * class NeedsService {\n   *   constructor(public service:UsefulService) {}\n   * }\n   *\n   * var injector = Injector.resolveAndCreate([NeedsService, UsefulService]);\n   * expect(injector.get(NeedsService).service instanceof UsefulService).toBe(true);\n   * ```\n   * {@link Injector} will throw {@link NoAnnotationError} when trying to instantiate a class that\n   * does not have `@Injectable` marker, as shown in the example below.\n   *\n   * ```typescript\n   * class UsefulService {}\n   *\n   * class NeedsService {\n   *   constructor(public service:UsefulService) {}\n   * }\n   *\n   * var injector = Injector.resolveAndCreate([NeedsService, UsefulService]);\n   * expect(() => injector.get(NeedsService)).toThrowError();\n   * ```\n   * @stable\n   */\n  (): any;\n  new (): Injectable;\n}\n\n/**\n * Type of the Injectable metadata.\n *\n * @stable\n */\nexport interface Injectable {}\n\n/**\n * Injectable decorator and metadata.\n *\n * @stable\n * @Annotation\n */\nexport const Injectable: InjectableDecorator = makeParamDecorator('Injectable', []);\n\n/**\n * Type of the Self decorator / constructor function.\n *\n * @stable\n */\nexport interface SelfDecorator {\n  /**\n   * Specifies that an {@link Injector} should retrieve a dependency only from itself.\n   *\n   * ### Example ([live demo](http://plnkr.co/edit/NeagAg?p=preview))\n   *\n   * ```typescript\n   * class Dependency {\n   * }\n   *\n   * @Injectable()\n   * class NeedsDependency {\n   *   dependency;\n   *   constructor(@Self() dependency:Dependency) {\n   *     this.dependency = dependency;\n   *   }\n   * }\n   *\n   * var inj = Injector.resolveAndCreate([Dependency, NeedsDependency]);\n   * var nd = inj.get(NeedsDependency);\n   *\n   * expect(nd.dependency instanceof Dependency).toBe(true);\n   *\n   * var inj = Injector.resolveAndCreate([Dependency]);\n   * var child = inj.resolveAndCreateChild([NeedsDependency]);\n   * expect(() => child.get(NeedsDependency)).toThrowError();\n   * ```\n   * @stable\n   */\n  (): any;\n  new (): Self;\n}\n\n/**\n * Type of the Self metadata.\n *\n * @stable\n */\nexport interface Self {}\n\n/**\n * Self decorator and metadata.\n *\n * @stable\n * @Annotation\n */\nexport const Self: SelfDecorator = makeParamDecorator('Self', []);\n\n\n/**\n * Type of the SkipSelf decorator / constructor function.\n *\n * @stable\n */\nexport interface SkipSelfDecorator {\n  /**\n   * Specifies that the dependency resolution should start from the parent injector.\n   *\n   * ### Example ([live demo](http://plnkr.co/edit/Wchdzb?p=preview))\n   *\n   * ```typescript\n   * class Dependency {\n   * }\n   *\n   * @Injectable()\n   * class NeedsDependency {\n   *   dependency;\n   *   constructor(@SkipSelf() dependency:Dependency) {\n   *     this.dependency = dependency;\n   *   }\n   * }\n   *\n   * var parent = Injector.resolveAndCreate([Dependency]);\n   * var child = parent.resolveAndCreateChild([NeedsDependency]);\n   * expect(child.get(NeedsDependency).dependency instanceof Depedency).toBe(true);\n   *\n   * var inj = Injector.resolveAndCreate([Dependency, NeedsDependency]);\n   * expect(() => inj.get(NeedsDependency)).toThrowError();\n   * ```\n   * @stable\n   */\n  (): any;\n  new (): SkipSelf;\n}\n\n/**\n * Type of the SkipSelf metadata.\n *\n * @stable\n */\nexport interface SkipSelf {}\n\n/**\n * SkipSelf decorator and metadata.\n *\n * @stable\n * @Annotation\n */\nexport const SkipSelf: SkipSelfDecorator = makeParamDecorator('SkipSelf', []);\n\n/**\n * Type of the Host decorator / constructor function.\n *\n * @stable\n */\nexport interface HostDecorator {\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * closest host.\n   *\n   * In Angular, a component element is automatically declared as a host for all the injectors in\n   * its view.\n   *\n   * ### Example ([live demo](http://plnkr.co/edit/GX79pV?p=preview))\n   *\n   * In the following example `App` contains `ParentCmp`, which contains `ChildDirective`.\n   * So `ParentCmp` is the host of `ChildDirective`.\n   *\n   * `ChildDirective` depends on two services: `HostService` and `OtherService`.\n   * `HostService` is defined at `ParentCmp`, and `OtherService` is defined at `App`.\n   *\n   *```typescript\n   * class OtherService {}\n   * class HostService {}\n   *\n   * @Directive({\n   *   selector: 'child-directive'\n   * })\n   * class ChildDirective {\n   *   constructor(@Optional() @Host() os:OtherService, @Optional() @Host() hs:HostService){\n   *     console.log(\"os is null\", os);\n   *     console.log(\"hs is NOT null\", hs);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'parent-cmp',\n   *   providers: [HostService],\n   *   template: `\n   *     Dir: <child-directive></child-directive>\n   *   `,\n   *   directives: [ChildDirective]\n   * })\n   * class ParentCmp {\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   providers: [OtherService],\n   *   template: `\n   *     Parent: <parent-cmp></parent-cmp>\n   *   `,\n   *   directives: [ParentCmp]\n   * })\n   * class App {\n   * }\n   *```\n   * @stable\n   */\n  (): any;\n  new (): Host;\n}\n\n/**\n * Type of the Host metadata.\n *\n * @stable\n */\nexport interface Host {}\n\n/**\n * Host decorator and metadata.\n *\n * @stable\n * @Annotation\n */\nexport const Host: HostDecorator = makeParamDecorator('Host', []);\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}