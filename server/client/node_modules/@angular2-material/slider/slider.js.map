{"version":3,"file":"slider.js","sourceRoot":"","sources":["../../usr/local/google/home/jelbourn/material2/tmp/broccoli_type_script_compiler-input_base_path-oPmWLW1O.tmp/0/src/demo-app/components/slider/slider.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  NgModule,\n  Component,\n  ElementRef,\n  HostBinding,\n  Input,\n  ViewEncapsulation,\n  AfterContentInit,\n} from '@angular/core';\nimport {HAMMER_GESTURE_CONFIG} from '@angular/platform-browser';\nimport {BooleanFieldValue} from '@angular2-material/core/annotations/field-value';\nimport {applyCssTransform} from '@angular2-material/core/style/apply-transform';\nimport {MdGestureConfig} from '@angular2-material/core/core';\n\n/**\n * Visually, a 30px separation between tick marks looks best. This is very subjective but it is\n * the default separation we chose.\n */\nconst MIN_AUTO_TICK_SEPARATION = 30;\n\n@Component({\n  moduleId: module.id,\n  selector: 'md-slider',\n  host: {\n    'tabindex': '0',\n    '(click)': 'onClick($event)',\n    '(slide)': 'onSlide($event)',\n    '(slidestart)': 'onSlideStart($event)',\n    '(slideend)': 'onSlideEnd()',\n    '(window:resize)': 'onResize()',\n    '(blur)': 'onBlur()',\n  },\n  templateUrl: 'slider.html',\n  styleUrls: ['slider.css'],\n  encapsulation: ViewEncapsulation.None,\n})\nexport class MdSlider implements AfterContentInit {\n  /** A renderer to handle updating the slider's thumb and fill track. */\n  private _renderer: SliderRenderer = null;\n\n  /** The dimensions of the slider. */\n  private _sliderDimensions: ClientRect = null;\n\n  @Input()\n  @BooleanFieldValue()\n  @HostBinding('class.md-slider-disabled')\n  @HostBinding('attr.aria-disabled')\n  disabled: boolean = false;\n\n  /** The miniumum value that the slider can have. */\n  private _min: number = 0;\n\n  /** The maximum value that the slider can have. */\n  private _max: number = 100;\n\n  /** The percentage of the slider that coincides with the value. */\n  private _percent: number = 0;\n\n  /** The values at which the thumb will snap. */\n  @Input() step: number = 1;\n\n  /**\n   * How often to show ticks. Relative to the step so that a tick always appears on a step.\n   * Ex: Tick interval of 4 with a step of 3 will draw a tick every 4 steps (every 12 values).\n   */\n  @Input('tick-interval') private _tickInterval: 'auto' | number;\n\n  /**\n   * Whether or not the thumb is sliding.\n   * Used to determine if there should be a transition for the thumb and fill track.\n   * TODO: internal\n   */\n  isSliding: boolean = false;\n\n  /**\n   * Whether or not the slider is active (clicked or sliding).\n   * Used to shrink and grow the thumb as according to the Material Design spec.\n   * TODO: internal\n   */\n  isActive: boolean = false;\n\n  /** Indicator for if the value has been set or not. */\n  private _isInitialized: boolean = false;\n\n  /** Value of the slider. */\n  private _value: number = 0;\n\n  @Input()\n  @HostBinding('attr.aria-valuemin')\n  get min() {\n    return this._min;\n  }\n\n  set min(v: number) {\n    // This has to be forced as a number to handle the math later.\n    this._min = Number(v);\n\n    // If the value wasn't explicitly set by the user, set it to the min.\n    if (!this._isInitialized) {\n      this.value = this._min;\n    }\n  }\n\n  @Input()\n  @HostBinding('attr.aria-valuemax')\n  get max() {\n    return this._max;\n  }\n\n  set max(v: number) {\n    this._max = Number(v);\n  }\n\n  @Input()\n  @HostBinding('attr.aria-valuenow')\n  get value() {\n    return this._value;\n  }\n\n  set value(v: number) {\n    this._value = Number(v);\n    this._isInitialized = true;\n  }\n\n  constructor(elementRef: ElementRef) {\n    this._renderer = new SliderRenderer(elementRef);\n  }\n\n  /**\n   * Once the slider has rendered, grab the dimensions and update the position of the thumb and\n   * fill track.\n   * TODO: internal\n   */\n  ngAfterContentInit() {\n    this._sliderDimensions = this._renderer.getSliderDimensions();\n    this.snapToValue();\n    this._updateTickSeparation();\n  }\n\n  /** TODO: internal */\n  onClick(event: MouseEvent) {\n    if (this.disabled) {\n      return;\n    }\n\n    this.isActive = true;\n    this.isSliding = false;\n    this._renderer.addFocus();\n    this.updateValueFromPosition(event.clientX);\n    this.snapToValue();\n  }\n\n  /** TODO: internal */\n  onSlide(event: HammerInput) {\n    if (this.disabled) {\n      return;\n    }\n\n    // Prevent the slide from selecting anything else.\n    event.preventDefault();\n    this.updateValueFromPosition(event.center.x);\n  }\n\n  /** TODO: internal */\n  onSlideStart(event: HammerInput) {\n    if (this.disabled) {\n      return;\n    }\n\n    event.preventDefault();\n    this.isSliding = true;\n    this.isActive = true;\n    this._renderer.addFocus();\n    this.updateValueFromPosition(event.center.x);\n  }\n\n  /** TODO: internal */\n  onSlideEnd() {\n    this.isSliding = false;\n      this.snapToValue();\n  }\n\n  /** TODO: internal */\n  onResize() {\n    this.isSliding = true;\n    this._sliderDimensions = this._renderer.getSliderDimensions();\n    // Skip updating the value and position as there is no new placement.\n    this._renderer.updateThumbAndFillPosition(this._percent, this._sliderDimensions.width);\n  }\n\n  /** TODO: internal */\n  onBlur() {\n    this.isActive = false;\n  }\n\n  /**\n   * When the value changes without a physical position, the percentage needs to be recalculated\n   * independent of the physical location.\n   * This is also used to move the thumb to a snapped value once sliding is done.\n   */\n  updatePercentFromValue() {\n    this._percent = this.calculatePercentage(this.value);\n  }\n\n  /**\n   * Calculate the new value from the new physical location. The value will always be snapped.\n   */\n  updateValueFromPosition(pos: number) {\n    let offset = this._sliderDimensions.left;\n    let size = this._sliderDimensions.width;\n\n    // The exact value is calculated from the event and used to find the closest snap value.\n    this._percent = this.clamp((pos - offset) / size);\n    let exactValue = this.calculateValue(this._percent);\n\n    // This calculation finds the closest step by finding the closest whole number divisible by the\n    // step relative to the min.\n    let closestValue = Math.round((exactValue - this.min) / this.step) * this.step + this.min;\n    // The value needs to snap to the min and max.\n    this.value = this.clamp(closestValue, this.min, this.max);\n    this._renderer.updateThumbAndFillPosition(this._percent, this._sliderDimensions.width);\n  }\n\n  /**\n   * Snaps the thumb to the current value.\n   * Called after a click or drag event is over.\n   */\n  snapToValue() {\n    this.updatePercentFromValue();\n    this._renderer.updateThumbAndFillPosition(this._percent, this._sliderDimensions.width);\n  }\n\n  /**\n   * Calculates the separation in pixels of tick marks. If there is no tick interval or the interval\n   * is set to something other than a number or 'auto', nothing happens.\n   */\n  private _updateTickSeparation() {\n    if (this._tickInterval == 'auto') {\n      this._updateAutoTickSeparation();\n    } else if (Number(this._tickInterval)) {\n      this._updateTickSeparationFromInterval();\n    }\n  }\n\n  /**\n   * Calculates the optimal separation in pixels of tick marks based on the minimum auto tick\n   * separation constant.\n   */\n  private _updateAutoTickSeparation() {\n    // We're looking for the multiple of step for which the separation between is greater than the\n    // minimum tick separation.\n    let sliderWidth = this._sliderDimensions.width;\n\n    // This is the total \"width\" of the slider in terms of values.\n    let valueWidth = this.max - this.min;\n\n    // Calculate how many values exist within 1px on the slider.\n    let valuePerPixel = valueWidth / sliderWidth;\n\n    // Calculate how many values exist in the minimum tick separation (px).\n    let valuePerSeparation = valuePerPixel  * MIN_AUTO_TICK_SEPARATION;\n\n    // Calculate how many steps exist in this separation. This will be the lowest value you can\n    // multiply step by to get a separation that is greater than or equal to the minimum tick\n    // separation.\n    let stepsPerSeparation = Math.ceil(valuePerSeparation / this.step);\n\n    // Get the percentage of the slider for which this tick would be located so we can then draw\n    // it on the slider.\n    let tickPercentage = this.calculatePercentage((this.step * stepsPerSeparation) + this.min);\n\n    // The pixel value of the tick is the percentage * the width of the slider. Use this to draw\n    // the ticks on the slider.\n    this._renderer.drawTicks(sliderWidth * tickPercentage);\n  }\n\n  /**\n   * Calculates the separation of tick marks by finding the pixel value of the tickInterval.\n   */\n  private _updateTickSeparationFromInterval() {\n    // Force tickInterval to be a number so it can be used in calculations.\n    let interval: number = <number> this._tickInterval;\n    // Calculate the first value a tick will be located at by getting the step at which the interval\n    // lands and adding that to the min.\n    let tickValue = (this.step * interval) + this.min;\n\n    // The percentage of the step on the slider is needed in order to calculate the pixel offset\n    // from the beginning of the slider. This offset is the tick separation.\n    let tickPercentage = this.calculatePercentage(tickValue);\n    this._renderer.drawTicks(this._sliderDimensions.width * tickPercentage);\n  }\n\n  /**\n   * Calculates the percentage of the slider that a value is.\n   */\n  calculatePercentage(value: number) {\n    return (value - this.min) / (this.max - this.min);\n  }\n\n  /**\n   * Calculates the value a percentage of the slider corresponds to.\n   */\n  calculateValue(percentage: number) {\n    return this.min + (percentage * (this.max - this.min));\n  }\n\n  /**\n   * Return a number between two numbers.\n   */\n  clamp(value: number, min = 0, max = 1) {\n    return Math.max(min, Math.min(value, max));\n  }\n}\n\n/**\n * Renderer class in order to keep all dom manipulation in one place and outside of the main class.\n */\nexport class SliderRenderer {\n  private _sliderElement: HTMLElement;\n\n  constructor(elementRef: ElementRef) {\n    this._sliderElement = elementRef.nativeElement;\n  }\n\n  /**\n   * Get the bounding client rect of the slider track element.\n   * The track is used rather than the native element to ignore the extra space that the thumb can\n   * take up.\n   */\n  getSliderDimensions() {\n    let trackElement = this._sliderElement.querySelector('.md-slider-track');\n    return trackElement.getBoundingClientRect();\n  }\n\n  /**\n   * Update the physical position of the thumb and fill track on the slider.\n   */\n  updateThumbAndFillPosition(percent: number, width: number) {\n    // A container element that is used to avoid overwriting the transform on the thumb itself.\n    let thumbPositionElement =\n        <HTMLElement>this._sliderElement.querySelector('.md-slider-thumb-position');\n    let fillTrackElement = <HTMLElement>this._sliderElement.querySelector('.md-slider-track-fill');\n\n    let position = percent * width;\n\n    fillTrackElement.style.width = `${position}px`;\n    applyCssTransform(thumbPositionElement, `translateX(${position}px)`);\n  }\n\n  /**\n   * Focuses the native element.\n   * Currently only used to allow a blur event to fire but will be used with keyboard input later.\n   */\n  addFocus() {\n    this._sliderElement.focus();\n  }\n\n  /**\n   * Draws ticks onto the tick container.\n   */\n  drawTicks(tickSeparation: number) {\n    let tickContainer = <HTMLElement>this._sliderElement.querySelector('.md-slider-tick-container');\n    let tickContainerWidth = tickContainer.getBoundingClientRect().width;\n    // An extra element for the last tick is needed because the linear gradient cannot be told to\n    // always draw a tick at the end of the gradient. To get around this, there is a second\n    // container for ticks that has a single tick mark on the very right edge.\n    let lastTickContainer =\n        <HTMLElement>this._sliderElement.querySelector('.md-slider-last-tick-container');\n    // Subtract 1 from the tick separation to center the tick.\n    // TODO: Evaluate the rendering performance of using repeating background gradients.\n    tickContainer.style.background = `repeating-linear-gradient(to right, black, black 2px, ` +\n        `transparent 2px, transparent ${tickSeparation - 1}px)`;\n    // Add a tick to the very end by starting on the right side and adding a 2px black line.\n    lastTickContainer.style.background = `linear-gradient(to left, black, black 2px, transparent ` +\n        `2px, transparent)`;\n\n    // If the second to last tick is too close (a separation of less than half the normal\n    // separation), don't show it by decreasing the width of the tick container element.\n    if (tickContainerWidth % tickSeparation < (tickSeparation / 2)) {\n      tickContainer.style.width = tickContainerWidth - tickSeparation + 'px';\n    }\n  }\n}\n\n/** @deprecated */\nexport const MD_SLIDER_DIRECTIVES = [MdSlider];\n\n\n@NgModule({\n  exports: MD_SLIDER_DIRECTIVES,\n  declarations: MD_SLIDER_DIRECTIVES,\n  providers: [\n    {provide: HAMMER_GESTURE_CONFIG, useClass: MdGestureConfig},\n  ],\n})\nexport class MdSliderModule { }\n"]}